# Memory Plumber
A small program written in C and C++ as an exercise, to track memory allocations made by another application and detect and identify any memory leaks.


### How it works
1. The symbols for malloc() and free() are overriden with custom functions of the same name that track the memory allocations (address and size) using LD_PRELOAD so that, in the target application, whenever calls are made to malloc() or free(), the custom logic is called first without requiring any change in the source code.

2. Each time memory is allocated by the application using malloc(), the custom implementation of malloc will track the allocations made in a hashmap with keys generated by hashing the pointer addresses and the keys map to pointers to structs that contain info about the allocation:

    ```
    typedef struct alloc_mem {
        void* ptr;              // Memory address where memory is being allocated from
        size_t size;            // Size of allocation 
        struct alloc_mem* next; // Hashmap uses chaining for key collisions- this is like a linked list
        bool in_use;            // Is the chunk of memory starting at this address is currently being used
        void* stack[32];        // stack trace
        int stack_size;         // num frames
    } AllocRecord;
    ```

    And the hash map is a static preallocated array: `static AllocRecord* alloc_record_map[4096]`

3. At every allocation with a call to malloc(), the custom implementation of malloc() will save information in an AllocRecord instance and insert a pointer to it in the hash table after hashing the pointer address, and then call the libc version of malloc as usual

4. At every call to free(void* mem_addr), the custom implementation of free(void* mem_addr) will look for the AllocationRecord* corresponding to hashed value of `mem_addr` in the hash map, and remove it. And then call the libc version of free() as usual

5. At the end, when the application in question is exiting, this program will run 
