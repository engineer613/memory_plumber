# Memory Plumber
A small demo library written in C and C++ as an exercise, to track memory allocations made by another application and detect and identify any memory leaks.

### ToDo
1. Code cleanup- split mem_plumber into header (.hpp) and implementation (.cpp ) files
2. Create a CMake file for easier compilation
3. Override other allocation functions like `calloc()` and `realloc()` if necessary  
4. Get rid of redundant "." characters in the stack trace for detected memory leaks (paths are not broken though, can be used as-is)   


### Demo

**_To test out mem_plumber, a very small C++ program that doesn't deallocate heap memory is included in this repo (`leaky_example.cpp`) and can be run along with the memory plumber by running the `compile-and-run.sh` script included with this repo:_**

```
./compile-and-run.sh


MEMORY LEAKS DETECTED:


  Leaking 20 bytes at 0x60e431b142b0
  Allocation Backtrace:
    ./memory_plumber/./leaky_example.cpp:6
    ./memory_plumber/./leaky_example.cpp:11
    ./memory_plumber/./leaky_example.cpp:13
    ./memory_plumber/./leaky_example.cpp:19
    ./csu/../csu/libc-start.c:128

```




### How it works
1. **The symbols for `malloc()` and `free()` are overriden with custom function symbols of the same name at the linker level, using `LD_PRELOAD` (Dynamic Function Interposition). The custom `malloc()` and `free()` implementations track the memory allocations (address and size), in the target application, whenever calls are made to malloc() or free()**
   
2. The original libc versions of `malloc()` and `free()` are obtained at init using `dlsym()`, stored in function pointers and called inside the custom malloc() implementation after saving information about the size and address of the memory allocation performed by the target application.


3. Each time memory is allocated by the application using malloc(), the custom implementation of malloc will track the allocations made in a hashmap with keys generated by hashing the pointer addresses. The keys map to allocation records that contain info about the allocation:

    ```
    typedef struct alloc_mem {
        void* ptr;              // Memory address where memory is being allocated from
        size_t size;            // Size of allocation 
        struct alloc_mem* next; // Hashmap uses chaining for key collisions- this is like a linked list
        bool in_use;            // Is the chunk of memory starting at this address is currently being used
        void* stack[32];        // stack trace
        int stack_size;         // num frames
    } AllocRecord;
    ```

    And the hash map is a static preallocated array: `static AllocRecord* alloc_record_map[4096]`

4. At every memory allocation with a call to `malloc()`, the custom implementation of `malloc()` will save information in an `AllocRecord` instance and insert a pointer to it in the hash table after hashing the pointer address, and then call the libc version of `malloc()` as usual and return the pointer address of allocated memory. When the target application made a call to `malloc()` or used STL which in turn made a call to `malloc()` underneath this is what would occur:

   ```  
    1. malloc() call in application
    2. Calls custom malloc() function 
    3. Inside custom malloc() function, call the libc versio of malloc() stored in a function pointer
    4. libc malloc returns a pointer address. Store the pointer address, size of allocation and stacktrace in a hashmap
    5. Return the pointer address like libc malloc() does
   ```
    

6. At every call to `free(void* mem_addr)`, the custom implementation of `free(void* mem_addr)` will look for the `AllocationRecord*` corresponding to hashed value of `mem_addr` in the hash map, and remove it. And then call the libc version of free() as usual. Similarly when  free() is called from the target application:

   ```
   1. free(mem_ptr) call in application
   2. Calls custom free(mem_ptr) function implemented in mem_plumber.cpp
   3. Inside custom free(mem_ptr) implementation, hash the pointer address and look up the key (hashed value) in the allocation table
   4. If the Allocation Record corresponding to the mem_ptr address is found, it is freed and the function call returns just like the libc free() function
   ```

7. The hashmap in which the allocation records are stored is marked `static` and also wrapped in a pthread_mutex_t, so if the target application is multithreaded, multiple threads write to the same instance of the hashmap without any data races.

8. At the end, when the application in question is exiting, mem_plumber will run a function to print out information about the memory allocations that were never deallocated along with the relevant backtrace from the application to pin point the memory leaks.


### Usage

- Compile mem_plumber as a `.so` library using g++ with the following flags:

    ```
    g++ -g -fPIC -shared -o libmemplumber.so $MEM_PLUMBER_SRC -ldl -rdynamic -lpthread
    ```

- Compile the target C/C++ application also using g++:
    ```
    g++ -g -o leaky_application leaky_application.cpp  # -g flag is required for debug symbols to let addr2line resolve the stack trace to file names and line numbers
    ```


- Then run the application in which memory leaks are suspected like this:

    ```
    LD_PRELOAD=./libmemplumber.so ./application_with_mem_leaks
    ```


-  _**When the application exits, the library should print out any memory leaks with relevant stack trace at the time of allocation.**_



