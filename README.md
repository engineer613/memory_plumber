# Memory Plumber
A small program written in C and C++ as an exercise, to track memory allocations made by another application and detect and identify any memory leaks.


### How it works
1. The symbols for malloc() and free() are overriden with custom functions of the same name that track the memory allocations (address and size) using LD_PRELOAD so that, in the target application, whenever calls are made to malloc() or free(), the custom logic is called first without requiring any change in the source code.

2. Each time memory is allocated by the application using malloc(), the custom implementation of malloc will track the allocations made in a hashmap with keys generated by hashing the pointer addresses. The keys map to allocation records that contain info about the allocation:

    ```
    typedef struct alloc_mem {
        void* ptr;              // Memory address where memory is being allocated from
        size_t size;            // Size of allocation 
        struct alloc_mem* next; // Hashmap uses chaining for key collisions- this is like a linked list
        bool in_use;            // Is the chunk of memory starting at this address is currently being used
        void* stack[32];        // stack trace
        int stack_size;         // num frames
    } AllocRecord;
    ```

    And the hash map is a static preallocated array: `static AllocRecord* alloc_record_map[4096]`

3. At every memory allocation with a call to `malloc()`, the custom implementation of `malloc()` will save information in an `AllocRecord` instance and insert a pointer to it in the hash table after hashing the pointer address, and then call the libc version of `malloc()` as usual and return the pointer address of allocated memory

4. At every call to `free(void* mem_addr)`, the custom implementation of `free(void* mem_addr)` will look for the `AllocationRecord*` corresponding to hashed value of `mem_addr` in the hash map, and remove it. And then call the libc version of free() as usual

5. At the end, when the application in question is exiting, this program will run a function to print out information about the memory allocations that were never deallocated along with the relevant backtrace from the application to pin point the memory leaks.


### Usage

- Compile mem_plumber using g++ with the following flags:

    ```
    g++ -g -fPIC -shared -o libmemplumber.so $MEM_PLUMBER_SRC -ldl -rdynamic -lpthread
    ```

- Then run the application in which memory leaks are suspected like this:

    ```
    LD_PRELOAD=./libmemplumber.so ./application_with_mem_leaks
    ```


- When the application exits, the library should print out any memory leaks with relevant stack trace at the time of allocation. 


Alternatively, a very small C++ program that doesn't deallocate heap memory is included in this repo (`leaky_example.cpp`) and can be run with memory plumber by running the `compile-and-run.sh` script included in this repo:

```
./compile-and-run.sh


MEMORY LEAKS DETECTED:


  Leaking 20 bytes at 0x60e431b142b0
  Allocation Backtrace:
    ./memory_plumber/./leaky_example.cpp:6
    ./memory_plumber/./leaky_example.cpp:11
    ./memory_plumber/./leaky_example.cpp:13
    ./memory_plumber/./leaky_example.cpp:19
    ./csu/../csu/libc-start.c:128

```